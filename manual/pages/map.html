<h2>Map generation</h2>

<p>There are several map generator tools in <code>rot.js</code>; they all share the same usage pattern. You first need to instantialize the proper <code>ROT.Map.*</code> 
object and pass size (plus any additional relevant options) to its constructor; you can then call the main <code>create</code> method (repeatedly, if you want).</p>

<p>This toolkit does not force usage of any particular memory structure to store the map data. Instead, the map creation process is <em>callback-based</em>: 
you supply a callback function as an argument to the <code>create</code> method; 
the map creator will call your function repeatedly and pass it the generated map information. Your callback should accept these arguments:</p>

<ul>
	<li><code>x</code> &ndash; horizontal coordinate of a map's cell</li>
	<li><code>y</code> &ndash; vertical coordinate of a map's cell</li>
	<li><code>value</code> &ndash; integer value corresponding to the type of generated cell (different values might be supplied by different map generators)</li>
</ul>

<p>These examples use the simplest map generator, <code>Arena</code>: a fully dug room.</p>

<div class="example">
var map = new ROT.Map.Arena(3, 3);
var userCallback = function(x, y, value) {
	SHOW("Value %s generated at [%s,%s]".format(value, x, y));
}
map.create(userCallback);
</div>

<p>We can use <code><a href="#display">ROT.Display</a></code> to show the generated map (although it would make more sense to store the generated data as well). For debugging purposes, 
<code>ROT.Display</code> provides a built-in convenience method <code>DEBUG</code>, which works as a universal debugging callback.</p>

<div class="example">
var map = new ROT.Map.Arena(10, 5);

var display1 = new ROT.Display({width:10, height:5, fontSize:18});
SHOW(display1.getContainer());

map.create(function(x, y, wall) {
	display1.draw(x, y, wall ? "#" : ".");
});

/* debugging with small font */
var display2 = new ROT.Display({width:10, height:5, fontSize:8});
SHOW(display2.getContainer());
map.create(display2.DEBUG);
</div>

<h2>Maze generators</h2>

<p>This family of algorithms uses the following callback values:</p>
<ul>
	<li><code>0</code>: empty space</li>
	<li><code>1</code>: wall</li>
</ul>

<h3>DividedMaze</h3>

<p>Based on a <a href="http://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_division_method">Recursive division method</a>.</p>

<div class="example">
var w = 39, h = 25;
var dm = new ROT.Map.DividedMaze(w, h);

for (var i=0; i&lt;4; i++) {
	var display = new ROT.Display({width:w, height:h, fontSize:6});
	SHOW(display.getContainer());

	dm.create(display.DEBUG);
}
</div>

<h3>Icey's Maze</h3>

<p>Cool mazes with a configurable regularity can be created using this <a href="http://www.roguebasin.roguelikedevelopment.org/index.php?title=Simple_maze#Maze_Generator_in_Visual_Basic_6">algorithm</a>, 
taken from a Rogue Basin wiki. Regularity is an integer value, specified as a third argument; 0 = most random.</p>

<div class="example">
var w = 39, h = 25;

for (var i=0; i&lt;4; i++) {
	var display = new ROT.Display({width:w, height:h, fontSize:6});
	SHOW(display.getContainer());

	var maze = new ROT.Map.IceyMaze(w, h, 4*i);
	maze.create(display.DEBUG);
}
</div>

<h3>Eller's Perfect Maze</h3>

<p>For a full explanation of this wonderful Eller's algorithm, please see 
<a href="http://homepages.cwi.nl/~tromp/maze.html">http://homepages.cwi.nl/~tromp/maze.html</a>. 
Not only it generates a <em>Perfect maze</em> (every two cells are connected by exactly one path), 
but it only requires 2*N memory to generate a maze of N*N size!</p>

<div class="example">
var w = 39, h = 25;
var em = new ROT.Map.EllerMaze(w, h);

for (var i=0; i&lt;4; i++) {
	var display = new ROT.Display({width:w, height:h, fontSize:6});
	SHOW(display.getContainer());

	em.create(display.DEBUG);
}
</div>

<h2>Dungeon generators</h2>

<p>FIXME</p>

<h2>Cellular automata generator</h2>

<p>Interesting cave systems can be created using <code>ROT.Map.Cellular</code>, a generator which simulates a cellular automaton. Using this generator is a bit more complex, 
because it offers richer features and is more configurable.</p>

<p>Apart from the traditional width and height arguments, <code>ROT.Map.Cellular</code> accepts also a configuration object with the following optional keys:</p>
<ul>
	<li><code>born</code> &ndash; array of neighbor counts; when an empty cell has this number of neighbors, a new cell is born</li>
	<li><code>survive</code> &ndash; array of neighbor counts; when an existing cell has this number of neighbors, it will survive into next iteration</li>
	<li><code>topology</code> &ndash; how are neighbors defined: a cell can have four, six or eight neighbors. Six neighbors correspond to the "hex" layouting algorithm 
	of <a href="#display">ROT.Display</a>.</li>
</ul>

<p>It is also possible to initialize/set values for the first generation of cells. Two methods are provided:</p>
<ul>
	<li><code>set(x, y, value)</code> to directly set a cell</li>
	<li><code>randomize(probability)</code> set all cells to "alive" with a given probability (0 = no cells, 1 = all cells)</li>
</ul>

<p>It is possible (and desirable) to call the <code>create</code> method repeatedly: every call will create a new generation. There is no need to specify a callback, 
if you only want to advance into next generation, without actually retrieving the current map data. By default, the <em>born</em> and <em>survive</em> options 
are set according to this <a href="http://www.roguebasin.roguelikedevelopment.org/index.php/Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels">Roguebasin article</a>.</p>

<p><code>ROT.Map.Cellular</code> uses the following callback values:</p>
<ul>
	<li><code>0</code>: no cell</li>
	<li><code>1</code>: alive cell</li>
</ul>

<div class="example">
var w = 80, h = 40;
var map = new ROT.Map.Cellular(w, h);

/* cells with 1/2 probability */
map.randomize(0.5);

/* generate and show four generations */
for (var i=0; i&lt;4; i++) {
	var display = new ROT.Display({width:w, height:h, fontSize:4});
	SHOW(display.getContainer());
	map.create(display.DEBUG);
}
</div>

<div class="example">
var w = 100, h = 60;
var display = new ROT.Display({width:w, height:h, fontSize:6});
SHOW(display.getContainer());

/* custom born/survive rules */
var map = new ROT.Map.Cellular(w, h, {
	born: [4, 5, 6, 7, 8],
	survive: [2, 3, 4, 5]
});

map.randomize(0.9);

/* generate fifty iterations, show the last one */
for (var i=49; i&gt;=0; i--) {
	map.create(i ? null : display.DEBUG);
}
</div>

<div class="example">
var w = 60, h = 60;
/* hexagonal layout */
var display = new ROT.Display({width:w, height:h, fontSize:10, layout:"hex"});
SHOW(display.getContainer());

/* hexagonal map and rules */
var map = new ROT.Map.Cellular(w, h, {
	topology: 6,
	born: [4, 5, 6],
	survive: [3, 4, 5, 6]
});

/* initialize with irregularly random values */
for (var i=0; i&lt;w; i++) {
	for (var j=0; j&lt;h; j++) {
		var dx = i/w - 0.5;
		var dy = j/h - 0.5;
		var dist = Math.pow(dx*dx+dy*dy, 0.33);
		if (ROT.RNG.getUniform() &lt; dist) { map.set(i, j, 1); }
	}
}

/* generate six iterations, show the last one */
for (var i=5; i&gt;=0; i--) {
	map.create(i ? null : display.DEBUG);
}
</div>
